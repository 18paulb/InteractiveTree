let data = [
  {
    "image": 1,
    "mother": null,
    "spouse": 2,
    "birthyear": 1888,
    "name": "Joseph P. Kennedy",
  },
  {
    "image": 2,
    "mother": null,
    "spouse": 1,
    "birthyear": 1890,
    "name": "Rose Fitzgerald",
  },
  {
    "image": 3,
    "mother": 2,
    "spouse": null,
    "birthyear": 1915,
    "name": "Joseph P. Kennedy Jr.",
  },
  {
    "image": 4,
    "mother": 2,
    "spouse": 5,
    "birthyear": 1917,
    "name": "John F. Kennedy",
  },
  {
    "image": 5,
    "mother": null,
    "spouse": 4,
    "birthyear": 1929,
    "name": "Jacqueline Bouvier",
  },
  {
    "image": 6,
    "mother": 5,
    "spouse": null,
    "birthyear": 1957,
    "name": "Caroline Kennedy",
  },
  {
    "image": 7,
    "mother": 5,
    "spouse": null,
    "birthyear": 1960,
    "name": "John F. Kennedy Jr.",
  },
  {
    "image": 8,
    "mother": 2,
    "spouse": null,
    "birthyear": 1918,
    "name": "Rosemary Kennedy",
  },
  {
    "image": 9,
    "mother": 2,
    "spouse": 10,
    "birthyear": 1920,
    "name": "Kathleen Kennedy",
  },
  {
    "image": 10,
    "mother": null,
    "spouse": 9,
    "birthyear": 1917,
    "name": "William Cavendish",
  },
  {
    "image": 11,
    "mother": 2,
    "spouse": 12,
    "birthyear": 1921,
    "name": "Eunice Kennedy",
  },
  {
    "image": 12,
    "mother": null,
    "spouse": 11,
    "birthyear": 1915,
    "name": "Robert Shriver",
  },
  {
    "image": 13,
    "mother": 11,
    "spouse": null,
    "birthyear": 1955,
    "name": "Maria Shriver",
  },
  {
    "image": 14,
    "mother": 11,
    "spouse": null,
    "birthyear": 1959,
    "name": "Timothy Shriver",
  },
  {
    "image": 15,
    "mother": 11,
    "spouse": null,
    "birthyear": 1964,
    "name": "Mark Shriver",
  },
  {
    "image": 16,
    "mother": 11,
    "spouse": null,
    "birthyear": 1965,
    "name": "Anthony Shriver",
  },
  {
    "image": 17,
    "mother": 2,
    "spouse": 18,
    "birthyear": 1924,
    "name": "Patricia Kennedy",
  },
  {
    "image": 18,
    "mother": null,
    "spouse": 17,
    "birthyear": 1923,
    "name": "Peter Lawford",
  },
  {
    "image": 19,
    "mother": 17,
    "spouse": null,
    "birthyear": 1955,
    "name": "Christopher Lawford",
  },
  {
    "image": 20,
    "mother": 17,
    "spouse": null,
    "birthyear": 1956,
    "name": "Sydney Lawford",
  },
  {
    "image": 22,
    "mother": 17,
    "spouse": null,
    "birthyear": 1961,
    "name": "Robin Lawford",
  },
  {
    "image": 21,
    "mother": 17,
    "spouse": null,
    "birthyear": 1958,
    "name": "Victoria Lawford",
  },
  {
    "image": 23,
    "mother": 2,
    "spouse": 24,
    "birthyear": 1925,
    "name": "Robert Kennedy",
  },
  {
    "image": 24,
    "mother": null,
    "spouse": 23,
    "birthyear": 1928,
    "name": "Ethel Skakel",
  },
  {
    "image": 25,
    "mother": 24,
    "spouse": null,
    "birthyear": 1952,
    "name": "Robert F. Kennedy Jr.",
  },
  {
    "image": 26,
    "mother": 24,
    "spouse": null,
    "birthyear": 1955,
    "name": "David A. Kennedy",
  },
  {
    "image": 27,
    "mother": 24,
    "spouse": null,
    "birthyear": 1956,
    "name": "Mary Courtney Kennedy",
  },
  {
    "image": 28,
    "mother": 24,
    "spouse": null,
    "birthyear": 1958,
    "name": "Michael Kennedy",
  },
  {
    "image": 29,
    "mother": 24,
    "spouse": null,
    "birthyear": 1959,
    "name": "Mary Kennedy",
  },
  {
    "image": 30,
    "mother": 24,
    "spouse": null,
    "birthyear": 1963,
    "name": "Christopher Kennedy",
  },
  {
    "image": 31,
    "mother": 24,
    "spouse": null,
    "birthyear": 1965,
    "name": "Matthew Kennedy",
  },
  {
    "image": 32,
    "mother": 24,
    "spouse": null,
    "birthyear": 1967,
    "name": "Douglass Kennedy",
  },
  {
    "image": 33,
    "mother": 24,
    "spouse": null,
    "birthyear": 1968,
    "name": "Rory Kennedy",
  },
  {
    "image": 34,
    "mother": 2,
    "spouse": 35,
    "birthyear": 1928,
    "name": "Jean Kennedy",
  },
  {
    "image": 35,
    "mother": null,
    "spouse": 34,
    "birthyear": 1927,
    "name": "Stephen Smith",
  },
  {
    "image": 36,
    "mother": 34,
    "spouse": null,
    "birthyear": 1960,
    "name": "William Kennedy Smith",
  },
  {
    "image": 37,
    "mother": 34,
    "spouse": null,
    "birthyear": 1967,
    "name": "Amanda Smith",
  },
  {
    "image": 38,
    "mother": 2,
    "spouse": 39,
    "birthyear": 1932,
    "name": "Edward Kennedy",
  },
  {
    "image": 39,
    "mother": null,
    "spouse": 38,
    "birthyear": 1936,
    "name": "Joan Bennett Kennedy",
  },
  {
    "image": 40,
    "mother": 39,
    "spouse": null,
    "birthyear": 1960,
    "name": "Kara Kennedy",
  },
  {
    "image": 41,
    "mother": 39,
    "spouse": null,
    "birthyear": 1961,
    "name": "Edward Kennedy Jr.",
  },
  {
    "image": 42,
    "mother": 39,
    "spouse": null,
    "birthyear": 1967,
    "name": "Patrick Kennedy",
  },
]

//For multi Trees
let dataMap = new Map();

//Hard Coding Root Node for starting tree, just for sample data
//Notes: The key to each value in map is the id for the active node of the tree, if a hidden family becomes the active node, then the key is changed
dataMap.set(data[1].image, Array.from(data));

let nodeBoxData = [];

//Change this and HTML in order to change graph size
let chartWidth = 1000;

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//Defines class to be used for the objects of the values in momArray
class mom {
  children = [];
  data = null;

  addChild(child) {
    this.children.push(child);
  }
}

//Big O isn't ideal but it will save costs in other parts of the program
function makeMomArray() {
  let tmpArray = [];
  //Initializes momObjects and pushes data to the object
  for (let value of dataMap.values()) {
    for (let i = 0; i < value.length; ++i) {
      
      if (value[i].mother != null) {
        let tmpMom = new mom;
        tmpMom.data = getNode(value[i].mother);
        
        //checks for duplicates
        let isDuplicate = false;
        for (let j = 0; j < tmpArray.length; j++) {
          if (value[i].mother == tmpArray[j].data.image) {
            isDuplicate = true;
          }
        }
        if (!isDuplicate) {
          tmpArray.push(tmpMom);
        }
      }
    }
  }

  //Adds children to mom Object
  for (let i = 0; i < tmpArray.length; ++i) {
    let tmpChildren = []
    for (let value of dataMap.values()) {
      for (let j = 0; j < value.length; ++j) {
        if (value[j].mother == tmpArray[i].data.image) {
          tmpChildren.push(value[j]);
        }
      }
    }
    tmpArray[i].children = tmpChildren;
  }

  for (let i = 0; i < tmpArray.length; ++i) {
    let children = tmpArray[i].children
    for (let j = 0; j < children.length; ++j) {
      for (let k = 1; k < children.length; ++k) {
        if (k == j) {
          continue;
        }
        if (children[j].image == children[k].image) {
          children.splice(k,1);
          k--;
        }
      }
    }
  }

  return tmpArray;
}

//Used to connect children to moms
let momArray = makeMomArray();
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

let chartList = document.getElementById('chart');
createChart();

function createChart() {
  //Makes sure tree is empty
  for (let i = 0; i < chartList.children.length; ++i) {
    chartList.children[i].remove();
    i -= 1;
  }

  dataMap.forEach((value, key) => {
    
    let activeTree = []
    for (let i = 0; i < value.length; ++i) {

      if (value[i].image == key) {
        activeTree.push(value[i])
      }

      let root = getNode(key);
      if (isDescendant(value[i], root)) {
        activeTree.push(value[i])
      }
    }
    createDataPoints(activeTree);
  })

  dataMap.forEach((value, key) => {
    
    let activeTree = []
    for (let i = 0; i < value.length; ++i) {

      if (value[i].image == key) {
        activeTree.push(value[i])
      }
      
      if (isDescendant(value[i], getNode(key))) {
        activeTree.push(value[i])
      }
    }
    
    shiftChart(activeTree)
  })

  checkRootNode();

  createLines();
  
}

/**
 * Creates HTML elements for each node and sets their initial X and Y positions
 * @param {the current tree that's passed in} treeValue 
 */
function createDataPoints(treeValue) {
  
  //get highest gen in current tree
  let genCount = getLongestGenChain();
  
  //iterate through all of the gens in current tree
  for (let genIndex = 1; genIndex <= genCount; genIndex++) {
    
    //get all the nodes in the current gen
    let nodesInGen = getNodesInGeneration(genIndex);
    let nodesInTree = [];
    
    //iterate through all nodes in current gen
    for (let node = 0; node < nodesInGen.length; node++) {
      
      //get all nodes in the current tree
      //Protect against duplicates
      if (treeValue.includes(nodesInGen[node])) {
        let inTree = false;
        for (let i = 0; i < nodesInTree.length; ++i) {
          if (nodesInTree[i].image == nodesInGen[node].image) {
            inTree = true;
          }
        }

        if (!inTree) {
          nodesInTree.push(nodesInGen[node]);
        }
      }
    }

    //iterate through all the nodes in current tree and create an element for them
    for (let nodeIndex = 0; nodeIndex < nodesInTree.length; nodeIndex++) {
      let currNode = nodesInTree[nodeIndex];

      //create an element for each node
      let li = document.createElement('li');
      li.setAttribute('id', currNode.image);

      //define the Ypos of each element
      let yPos = setY(genIndex, genCount);

      //define the XPos of each element
      let xPos = setInitialX(genIndex, (nodeIndex + 1));
      
      //set the X and Y positions for each element
      li.setAttribute('style', `--y: ${Math.round(yPos)}px; --x: ${Math.round(xPos)}px`);

      //append each element to the tree
      /*
      li.innerHTML += `<div id='button${currNode.image}' onclick='openNodeOptions(${currNode.image})'>
      <img class="data-point data-button" src="../../static/tree/images/pictures/Kennedy/${currNode.image}.PNG" onmouseenter='hoverMenu(${currNode.image})' onmouseleave='closeHoverMenu()'>
      </div>`
      */

      //If it has a hidden family, makes node border tan, if it doesn not, the border is blue
      
      if (hasHiddenFamily(nodesInTree[nodeIndex])) {
        li.innerHTML += `<div id='button${currNode.image}' onclick='openNodeOptions(${currNode.image})'>
        <img class="data-point-hidden data-button" src="../../static/tree/images/pictures/Kennedy/${currNode.image}.PNG" onmouseenter='hoverMenu(${currNode.image})' onmouseleave='closeHoverMenu()'>
        </div>`
      }
      else {
        li.innerHTML += `<div id='button${currNode.image}' onclick='openNodeOptions(${currNode.image})'>
        <img class="data-point data-button" src="../../static/tree/images/pictures/Kennedy/${currNode.image}.PNG" onmouseenter='hoverMenu(${currNode.image})' onmouseleave='closeHoverMenu()'>
        </div>`
      }
      

      //Button for expanding a tree
      if (hasChildren(currNode)) {
        li.innerHTML += `<button id="${currNode.image}-hide-button" class='expand-tree' onclick="hideTree(${currNode.image}); changeButton(${currNode.image}, 'hide')">&#8593</button>`
      }
    
      chartList.appendChild(li);
    }
  }
}

function changeButton(id, method) {

  let hideButton = document.getElementById(`${id}-hide-button`);

  if (method == 'show') {
    hideButton.attributes.onclick.nodeValue = `hideTree(${id}); changeButton(${id}, 'hide')`;
    hideButton.innerHTML = "&#8593";
  }
  if (method == 'hide') {
    hideButton.attributes.onclick.nodeValue = `showTree(${id}); changeButton(${id}, 'show')`;
    hideButton.innerHTML = "&#8595";
  }

}

function createLines() {
  let svgString = '';

  //Test to increase size of SVG dynamically
  //Height might still not be perfectly scaled
  let svgelem = document.getElementById("lines")
  let svgWidth = svgelem.getBBox().width
  let svgHeight = svgelem.getBBox().height

  //Gets new width for SVG
  for (let value of dataMap.values()) {
    for (let i = 0; i < value.length; ++i) {
      if (isOnTree(value[i])) {
        let nodeXPos = getX(value[i].image);
        if (nodeXPos > svgWidth || nodeXPos == svgWidth) {
          svgWidth = nodeXPos + 50;
        }
      }
  
    }
  }

  svgelem.setAttribute("width", svgWidth)

  let id = 1;
  for (let value of dataMap.values()) {

    for (let i = 0; i < value.length; ++i) {
      if (isOnTree(value[i])) {
        if (!isHidden(value[i])) {
          let li = $(`#${value[i].image}`);
          let yPos = parseAttribute('y', li[0].style.cssText);
          let xPos = parseAttribute('x', li[0].style.cssText);

          //Creates Child Lines
          if (hasChildren(value[i]) && !hasHiddenChildren(value[i])) {

            let index = getMomArrayIndex(momArray, value[i].image);

            for (let j = 0; j < momArray[index].children.length; ++j) {

              let childElement = $(`#${momArray[index].children[j].image}`)

              let x1 = xPos;
              let x2 = parseAttribute('x', childElement[0].style.cssText);
              let y1 = yPos;
              let y2 = parseAttribute('y', childElement[0].style.cssText);

              let valId = value[i].image;


              svgString += `<line id="line${id}" x1="${x1}" y1="${chartWidth - y1}" x2="${x2}" y2="${chartWidth - y2}" stroke="black" stroke-width='5' onmouseover="SVGHoverColor(line${id}, 'enter', 'mother')" onmouseleave="SVGHoverColor(line${id}, 'leave', 'mother')" onclick='openRemoveRelationshipMenu(getNode(${valId}), momArray[${index}].children[${j}])'/>`

              id++;
            }
          }

          //Creates Spouse Lines
          if (value[i].spouse != null) {

            let spouseElement = $(`#${value[i].spouse}`);
            let spouseXPos = parseAttribute('x', spouseElement[0].style.cssText);
            let spouseYPos = parseAttribute('y', spouseElement[0].style.cssText);

            let valId = value[i].image;
            let valSpouse = value[i].spouse;


            let line = `<line id="line${id}" x1="${xPos}" y1="${chartWidth - yPos}" x2="${spouseXPos}" y2="${chartWidth - spouseYPos}" stroke="blue" stroke-width='5' onmouseover="SVGHoverColor(line${id}, 'enter', 'spouse')" onmouseleave="SVGHoverColor(line${id}, 'leave', 'spouse')" onclick='openRemoveRelationshipMenu(getNode(${valId}), getNode(${valSpouse}))'/>`
            
            //if statement so that two spouse lines aren't drawn between spouses
            if (spouseXPos > xPos) {
              svgString += line
            }

            id++;
          }
        }
      }
    }
  }

  svgString += "</svg>"
  $('#lines').html(svgString);
}

function SVGHoverColor(id, method, relation) {

  if (method == "enter" && relation == "mother") {
    id.setAttribute("stroke", "gray")
  }
  else if (method == "enter" && relation == "spouse") {
    id.setAttribute("stroke", "lightblue")
  }
  else if (method == "leave" && relation == "mother") {
    id.setAttribute("stroke", "black")
  }
  else if (method == "leave" && relation == "spouse") {
    id.setAttribute("stroke", "blue")
  } else {
    return
  }
}

function testAdd(node1, node2) {

  let id1 = node1.image;
  let id2 = node2.image;

  let id1Birthyear = node1.birthyear;
  let id2Birthyear = node2.birthyear;

  $('#menu-position').html(
    `<div id='center-menu' class='center-menu'>
      <div><button class="x-button" onclick='closeMenu(), returnConfirmBoxNodes(${id1}, ${id2})'><strong>X</strong></button></div>
      <div class='menu-pics-container'>
        <div style="display: flex; flex-direction: column; justify-content:center; align-items:center;">
          <img class='menu-pic' src='../../static/tree/images/pictures/Kennedy/${id1}.PNG'/>
          <div id ='node-${id1}-info' style='display: flex; justify-content:center; align-items:center; flex-direction: column; padding-top: 5px; text-align:center'>
            <div><b>${node1.name}</b></div>
            <div><b>${id1Birthyear}</b></div>
          </div>
        </div>
        <div style="display: flex; flex-direction: column; justify-content:center; align-items:center;">
          <img class='menu-pic' src='../../static/tree/images/pictures/Kennedy/${id2}.PNG'/>
          <div id ='node-${id2}-info' style='display: flex; justify-content:center; align-items:center; flex-direction: column; padding-top: 5px; text-align:center'>
            <div><b>${node2.name}</b></div>
            <div><b>${id2Birthyear}</b></div>
          </div>
        </div>
      </div>
      <div class='menu-button-container'>
        <button id='removeButton' class='button-34' onclick='removeRelationship(${id1}, ${id2})'>Remove Relationship</button>
        <button id='addMotherButton' class='button-34' onclick='addMotherRelationship(${id1}, ${id2})'>Add Mother/Child Relationship</button>
        <button id='addSpouseButton' class='button-34' onclick='addSpouseRelationship(${id1}, ${id2})'>Add Spouse Relationship</button>
      </div>
    </div>`)
}

function openRemoveRelationshipMenu(node1, node2) {
  let id1 = node1.image;
  let id2 = node2.image;

  let id1Birthyear = node1.birthyear;
  let id2Birthyear = node2.birthyear;

  $('#menu-position').html(
    `<div id='center-menu' class='center-menu'>
      <div><button class="x-button" onclick='closeMenu(), returnConfirmBoxNodes(${id1}, ${id2})'><strong>X</strong></button></div>
      <div class='menu-pics-container'>
        <div style="display: flex; flex-direction: column; justify-content:center; align-items:center;">
          <img class='menu-pic' src='../../static/tree/images/pictures/Kennedy/${id1}.PNG'/>
          <div id ='node-${id1}-info' style='display: flex; justify-content:center; align-items:center; flex-direction: column; padding-top: 5px; text-align:center'>
            <div><b>${node1.name}</b></div>
            <div><b>${id1Birthyear}</b></div>
          </div>
        </div>
        <div style="display: flex; flex-direction: column; justify-content:center; align-items:center;">
          <img class='menu-pic' src='../../static/tree/images/pictures/Kennedy/${id2}.PNG'/>
          <div id ='node-${id2}-info' style='display: flex; justify-content:center; align-items:center; flex-direction: column; padding-top: 5px; text-align:center'>
            <div><b>${node2.name}</b></div>
            <div><b>${id2Birthyear}</b></div>
          </div>
        </div>
      </div>
      <div class='menu-button-container'>
        <button id='removeButton' class='button-34' onclick='removeRelationship(${id1}, ${id2})'>Remove Relationship</button>
      </div>
    </div>`)
}

function openNodeOptions(nodeId) {
  let node = getNode(nodeId);
  let idBirthyear = node.birthyear;

  //If there is already a node, add the 2nd node
  //All code in if is just to parse the id
  if (document.getElementById("menu-position").innerHTML != "") {
    let container = document.getElementById("menu-position");
    let currMenuNodeId = container.children[0].id;
    let id = ""

    for (let i = 0; i < currMenuNodeId.length; ++i) {
      if (isNaN(currMenuNodeId[i])) {
        break;
      }
      id += currMenuNodeId[i];
    }

    id = parseInt(id);

    if (id == nodeId) {
      return;
    }

    testAdd(getNode(id), node);
    return;
  }

  $('#menu-position').html(
    `<div id='${nodeId}center-menu' class='center-menu'>
      <div><button class="x-button" onclick='closeMenu()'><strong>X</strong></button></div>
      <div id="menu-pics" class='menu-pics-container'>
        <div style="display: flex; flex-direction: column; justify-content:center; align-items:center;">
          <img class='menu-pic' src='../../static/tree/images/pictures/Kennedy/${nodeId}.PNG'/>
          <div id ='node-${nodeId}-info' style='display: flex; justify-content:center; align-items:center; flex-direction: column; padding-top: 5px;'>
            <div><b>${node.name}</b></div>
            <div><b>${idBirthyear}</b></div>
          </div>
        </div>
      </div>
      <div id="menu-buttons" class='menu-button-container'>
        <button id='hiddenFamilyButton' class='button-34' onclick='getHiddenFamily(${nodeId}); closeMenu()'>Show Hidden Family</button>
        <button id='editButton' class='button-34' onclick='editNode(${nodeId})'>Edit Info</button>
      </div>
    </div>`)

  //These if statements remove hiddenFamilyButton if there is no hidden family or the family is shown
  if (node.mother == null) {
    document.getElementById("hiddenFamilyButton").remove();
  }
  else if (getRootNode(node).image == getNode(getKeyofVal(node)).image) {
    document.getElementById("hiddenFamilyButton").remove();
  }
}

function editNode(id) {

  let node = getNode(id)
  let birthyear = node.birthyear;
  let name = node.name;

  $('#menu-buttons').html(
    `<form id="editForm">
      <div class="form-group">
        <label for="name">Name</label>
        <input type="text" class="form-control" id="name" value="${name}">
      </div>
      <div class="form-group">
        <label for="byear">Birthyear</label>
        <input type="text" class="form-control" id="byear" value="${birthyear}">
      </div>
      <button type="submit" class="btn btn-primary">Submit Edits</button>
    </form>`
  )

  $("#editForm").submit(function(e) {
    e.preventDefault();

    let inputYear = document.getElementById("byear").value
    let inputName = document.getElementById("name").value

    if (inputYear.length != 4) {
      alert("Birthyear must be 4 digit number")
      //returnConfirmBoxNodes(id)
      closeMenu();
      return;
    }

    for (let i = 0; i < inputYear.length; ++i) {
      let isNumber = parseInt(inputYear[i])
      if (isNaN(isNumber)) {
        alert("Birthyear must contain only numbers");
        //returnConfirmBoxNodes(id)
        closeMenu();
        return;
      }
    }

    node.birthyear = inputYear;
    node.name = inputName;

    closeMenu();
  })

}

function addSpouseRelationship(id1, id2) {
  //For Spouse -> Spouse
  let spouse1 = getNode(id1);
  let spouse2 = getNode(id2);

  //checks nodeBox
  let currTree;
  let spouse1Index;
  let spouse2Index;

  if (spouse1.mother == spouse2.image || spouse2.mother == spouse1.image) {
    removeRelationship(id1, id2)
  }

  //If spouse1 is in nodeBox and spouse2 is on tree, push spouse1 onto tree
  if (inNodeBox(spouse1) && isOnTree(spouse2)) {
    currTree = getTree(spouse2);
    currTree.push(spouse1);
    spouse1Index = getNodeBoxDataIndex(spouse1.image);
    nodeBoxData.splice(spouse1Index, 1);
  }

  //If spouse2 is in nodeBox and spouse1 is on tree, push spouse2 onto tree
  if (inNodeBox(spouse2) && isOnTree(spouse1)) {
    currTree = getTree(spouse1);
    currTree.push(spouse2);
    spouse2Index = getNodeBoxDataIndex(spouse2.image);
    nodeBoxData.splice(spouse2Index, 1);
  }

  //This statement can cause issue, might make the rootNode the father instead of mother, function adjustRootNodes fixes this problem
  if (inNodeBox(spouse1) && inNodeBox(spouse2)) {
    let tree = [spouse1, spouse2];

    //creates new tree
    dataMap.set(spouse1.image, tree);

    let spouse1Index = getNodeBoxDataIndex(spouse1.image);
    nodeBoxData.splice(spouse1Index, 1);
    let spouse2Index = getNodeBoxDataIndex(spouse2.image);
    nodeBoxData.splice(spouse2Index, 1);
  }

  if (isOnTree(spouse1) && isOnTree(spouse2)) {
    //Gets rid of the old spouse's spouse value
    if (spouse1.spouse != null) {
      //getNode(spouse1.spouse).spouse = null;
      let spouse = getNode(spouse1.spouse) 
      spouse.spouse = null
      if (!hasRelationship(spouse)) {
        addToNodeContainer(spouse.image);
        removeNodeFromTree(spouse);
      }
    }
    if (spouse2.spouse != null) {
      //getNode(spouse2.spouse).spouse = null;
      let spouse = getNode(spouse2.spouse) 
      spouse.spouse = null
      if (!hasRelationship(spouse)) {
        addToNodeContainer(spouse.image);
        removeNodeFromTree(spouse);
      }
    }



    spouse1.spouse = null;
    spouse2.spouse = null;
  }

  //assigns each node their new spouse
  if (getDataIndex(spouse1.image) != null) {
    spouse1.spouse = spouse2.image;
  }

  if (getDataIndex(spouse2.image) != null) {
    spouse2.spouse = spouse1.image
  }

  createChart();

  closeMenu();
}

function addMotherRelationship(id1, id2) {

  let node1 = getNode(id1);
  let node2 = getNode(id2);

  //Accounts for if you try to add a mother/child relationship to spouses
  if (node1.spouse == node2.image || node2.spouse == node1.image) {
    removeRelationship(id1, id2)
  }

  let mother;
  let child;

  if (node1.birthyear > node2.birthyear) {
    mother = node2;
    child = node1;
  } else {
    mother = node1;
    child = node2;
  }

  if (hasChildren(getNode(mother.spouse))) {
    alert("Spouse already has children, please add child to only one parent");
    returnConfirmBoxNodes(id1, id2);
    closeMenu();
    return;
  }

  //If child is in nodeBox and mother in tree
  if (inNodeBox(child) && isOnTree(mother)) {
    let currTree = getTree(mother);
    currTree.push(child);
    let childIndex = getNodeBoxDataIndex(child.image);
    nodeBoxData.splice(childIndex, 1);
  }

  //If child is on tree and mother in nodeBox
  if (isOnTree(child) && inNodeBox(mother)) {

    //If you are just trying to switch a child's mother and create new tree
    if (child.mother != null) {
      let tree = [child, mother];
      //Removes child from old tree
      let currTree = getTree(child);
      let childIndex = getDataIndex(child.image);
      currTree.splice(childIndex, 1);

      //creates new tree
      dataMap.set(mother.image, tree);
    }

    //If child is root node
    else if (hasChildren(child) && child.mother == null && (child.spouse == null || (child.spouse != null && getNode(child.spouse).mother == null))) {
      getTree(child).push(mother)
      dataMap.set(mother.image, getTree(child));
      dataMap.delete(child.image)
    }

    //If child's spouse is a root node
    else if (child.mother == null) {
      let key = getKeyofVal(child);
      dataMap.get(key).push(mother);
    }
    else {
      alert("check add function because something broke")
    }

    //Removes mom from nodeBoxData
    let momIndex = getNodeBoxDataIndex(mother.image);
    nodeBoxData.splice(momIndex, 1)

  }


  //if both are in nodeBox
  if (inNodeBox(child) && inNodeBox(mother)) {
    let tree = [child, mother]

    //creates new tree
    dataMap.set(mother.image, tree);

    //Removes mom and child from nodeBoxData
    let childIndex = getNodeBoxDataIndex(child.image);
    nodeBoxData.splice(childIndex, 1);
    let momIndex = getNodeBoxDataIndex(mother.image);
    nodeBoxData.splice(momIndex, 1);
  }

  //if both are on the chart
  if ((isOnTree(child) && isOnTree(mother))) {

    let momTree = getTree(mother);
    let childTree = getTree(child);

    //if they are on different trees and one tree needs to be combined with my other tree
    if ((momTree != childTree) && (getRootNode(childTree[0]).image == child.image || getRootNode(childTree[0]).spouse == child.image)) {
        combineTrees(momTree, childTree)
    }

    //If they are on different trees and the 2 trees do not need to be combined
    else if ((momTree != childTree) && (getRootNode(childTree[0]).image != child.image || getRootNode(childTree[0]).spouse != child.image)) {
      for (let i = 0; i < childTree.length; ++i) {
        if (childTree[i].image == child.image) {
          momTree.push(childTree[i])
          childTree.splice(i,1);
          break;
        }
      }
    }
    else {
      //Something
    }
  }

  child.mother = mother.image;

  momArray = makeMomArray();

  createChart();

  closeMenu();
}

function removeRelationship(id1, id2) {

  node1 = getNode(id1);
  node2 = getNode(id2);

  let isRelated = false;

  let oldRoot = getRootNode(node1);
  let newTree = []

  //Removes Spouse Relationship
  if (node1.spouse == id2) {

    isRelated = true;

    node1.spouse = null;
    node2.spouse = null;

    if (!hasRelationship(node1)) {
      addToNodeContainer(id1);
      removeNodeFromTree(node1);
    }

    if (!hasRelationship(node2)) {
      addToNodeContainer(id2);
      removeNodeFromTree(node2);
    }

    //If the removed relationship causes tree to be empty, take out of dataMap
    if (dataMap.get(node1.image) != null) {
      if (dataMap.get(node1.image).length == 0) {
        dataMap.delete(node1.image)
      }
    }
    if (dataMap.get(node2.image) != null) {
      if (dataMap.get(node2.image).length == 0) {
        dataMap.delete(node2.image)
      }
    }

    //multi tree changes
    //Note: Spouse is already removed
    if (node1.mother == null && !inNodeBox(node1)) {
      newTree = getTreeLine(node1, newTree);
      addToTreeMap(newTree, dataMap.get(oldRoot.image));
    }
    else if (node2.mother == null && !inNodeBox(node2)) {
      newTree = getTreeLine(node2, newTree);
      addToTreeMap(newTree, dataMap.get(oldRoot.image));
    }
    else {
      //Something
    }

    closeMenu();

    createChart();

    return;
  }

  let mother;
  let child;

  if (node1.birthyear > node2.birthyear) {
    mother = node2;
    child = node1;
  } else {
    mother = node1;
    child = node2;
  }

  debugger

  //Removes Mother/Child Relationship
  for (let i = 0; i < momArray.length; ++i) {
    if (momArray[i].data.image == mother.image) {
      for (let j = 0; j < momArray[i].children.length; ++j) {
        if (momArray[i].children[j].image == child.image) {
          isRelated = true;

          child.mother = null;

          if (!hasRelationship(child)) {
            addToNodeContainer(child.image);
            removeNodeFromTree(child);
          }

          momArray = makeMomArray();

          if (!hasRelationship(mother)) {
            addToNodeContainer(mother.image);
            removeNodeFromTree(mother);

            //If the mother does not have a relationship, and it is a root node, you can infer that the tree is empty
            if (dataMap.get(mother.image) != null && dataMap.get(mother.image).length == 0) {
              dataMap.delete(mother.image)
            }
            //In case the mother's children still exist
            if (dataMap.get(mother.image) != null && dataMap.get(mother.image).length > 0) {
              //Mother should only have one child if it reaches this point
              dataMap.set(child.image, dataMap.get(mother.image));
              dataMap.delete(mother.image);
            }
            /*
            if (momArray[i].children.length == j+1) {
              break;
            } else {
            continue
            }
            */
            break;
          }

          //If it is it's own root node          
          if ((getRootNode(child)?.image == child.image || getRootNode(child)?.image == child.spouse) && !inNodeBox(child)) {
            newTree = getTreeLine(child, newTree);
            oldRoot = getRootNode(mother);
            addToTreeMap(newTree, dataMap.get(oldRoot.image));
          }

          break;
        }
      }
    }
  }

  if (!isRelated) {
    alert("Error, No Direct Relationship");
  }

  createChart();

  closeMenu();
}

function addToTreeMap(newTree, oldTree) {

  let root = getRootNode(newTree[0])

  //Gets rid of nodes in the oldTree
  for (let i = 0; i < oldTree.length; ++i) {
    for (let j = 0; j < newTree.length; ++j) {
      if (newTree[j].image == oldTree[i].image) {
        oldTree.splice(i, 1);
        i -= 1
        break;
      }
    }
  }

  dataMap.set(root.image, newTree)
}

//Takes an entire tree and pushes it to another tree
function combineTrees(originalTree, treeToBeAdded) {

  let rootKey = getRootNode(treeToBeAdded[0]);

  let cmpRootKey = getRootNode(originalTree[0]);

  //Case to make sure that tree isn't added to itself, if they both have the same root
  if (rootKey.image == cmpRootKey.image) {
    return;
  }

  for (let i = 0; i < treeToBeAdded.length; ++i) {
    originalTree.push(treeToBeAdded[i]);
  }

  dataMap.delete(rootKey.image);
}

function addToNodeContainer(id) {
  nodeBoxData.push(getNode(id))

  let container = document.getElementById('nodeContainer');
  let nodeId = `node${id}`;
  let button = document.createElement('button');
  let img = document.createElement('img');

  img.setAttribute('id', nodeId);
  img.setAttribute('class', 'node-image');
  img.setAttribute('src', `../../static/tree/images/pictures/Kennedy/${id}.PNG`);

  button.setAttribute('id', `button${id}`);
  button.setAttribute('class', 'nodeBox-button');
  button.setAttribute('onclick', `openNodeOptions(${id}), removeFromNodeContainer(${id})`);

  button.appendChild(img);

  container.appendChild(button);

  openNavBottom()
}

function removeFromNodeContainer(id) {
  let container = document.getElementById('nodeContainer');

  let child = document.getElementById("button" + id);

  container.removeChild(child);
}

function hoverMenu(nodeId) {

  let hMenu = document.getElementById('hover-menu');
  let node = document.getElementById(nodeId);

  let dataNode = getNode(nodeId);

  let nodeX = parseAttribute('x', node.style.cssText);
  let nodeY = parseAttribute('y', node.style.cssText);

  let nodeIdName = dataNode.name;

  let yPlacement = 100;

  if (nodeY > 800) {
    yPlacement = -260;
  }

  //Make this class a datapoint technically and make XY pos's from there, just get X,Y from node and then adjust slightly for it to be near node
  hMenu.innerHTML = `
  <div id='hover-menu' class='hover-menu hover-point' style='--y: ${nodeY + yPlacement}px; --x: ${nodeX - 35}px'>
    <!-- <div>Node: ${dataNode.image}<br>x: ${nodeX} y: ${getY(nodeId)}</div> -->
    <img class='menu-pic' src='../../static/tree/images/pictures/Kennedy/${nodeId}.PNG'/>
    <div id ='node-${nodeId}-info' style='display: flex; justify-content:center; align-items:center; flex-direction: column;'>
      <div style="text-align:center"><b>${nodeIdName}</br></div>
      <div><b>${dataNode?.birthyear}</b></div>
    </div>
  </div>
  `
}

function closeHoverMenu() {
  let menu = document.getElementById('hover-menu');
  menu.innerHTML = '';
}

function closeMenu() {

  let menu = document.getElementById('menu-position')

  menu.innerHTML = '';
}

//Spacing
/*TODO: Explanation for spacing*/
function shiftChart(tree) {

  //3. Find the furthest down generation in the tree and adjust the spacing so there are no overlaps
  let rootNode = getNode(getKeyofVal(tree[0]))
  fixGenerationSpacing(tree, rootNode);

  //If there are multiple trees, then shift those trees to the right accordingly
  let treeSpace = getXBuffer(tree);
  if (dataMap.size > 1) {shiftTree(treeSpace, tree)};

  //4. Center Root Node between her leftmost and rightmost child
  adjustRootNode(rootNode);

  //1. Shift all nodes by a set margin to better align on the screen
  shiftNodesByMarginX(tree)
  shiftNodesByMarginY(tree)
}

function shiftNodesByMarginY(tree) {
  //Get the highest yPos on entire tree
  let yPos = getY(tree[0].image)
  for (let values of dataMap.values()) {
    for (let i = 0; i < values.length; ++i) {
      if (isOnTree(values[i])) {
        let checkYPos = getY(values[i].image);
        if (checkYPos > yPos) {
          yPos = checkYPos;
        }
      }
    }
  }
  if (yPos > 950) {
    shiftMargin = yPos - 950;
    //shift the yPos of every node downward so that highest node is 1050px
    for (let values of dataMap.values()) {
      for (let i = 0; i < values.length; ++i) {
        if (isOnTree(values[i])) {
          let node = document.getElementById(values[i].image);
          let originalY = parseAttribute('y', node.style.cssText);
          let originalX = parseAttribute('x', node.style.cssText);
          node.setAttribute('style', `--y: ${originalY - shiftMargin}px; --x: ${originalX}px`);
        }
      }
    }
  }
  if (yPos < 950) {
    shiftMargin = 950 - yPos;
    //shift the yPos of every node downward so that highest node is 1050px
    for (let values of dataMap.values()) {
      for (let i = 0; i < values.length; ++i) {
        if (isOnTree(values[i])) {
          let node = document.getElementById(values[i].image);
          let originalY = parseAttribute('y', node.style.cssText);
          let originalX = parseAttribute('x', node.style.cssText);
          node.setAttribute('style', `--y: ${originalY + shiftMargin}px; --x: ${originalX}px`);
        }
      }
    }
  }
}

//Shift all nodes over for better centering
function shiftNodesByMarginX(tree) {
  //Gets initial val
  let xPos = getX(tree[0].image);

  //Get the leftmost XPos on entire tree
  
  
  for (let value of dataMap.values()) {
    for (let i = 0; i < value.length; ++i) {
      if (isOnTree(value[i])) {
        let checkXPos = getX(value[i].image);
        if (checkXPos < xPos) {
          xPos = checkXPos;
        }
      }
    }
  }
  
 let shiftMargin;

 if (xPos > 50) {
    shiftMargin = xPos - 50;
    //shift the xPos of every node by the margin to the left so that furthest left node is 100px from left edge
    for (let values of dataMap.values()) {
      for (let i = 0; i < values.length; ++i) {
        if (isOnTree(values[i])) {
          let node = document.getElementById(values[i].image);
          let originalY = parseAttribute('y', node.style.cssText);
          let originalX = parseAttribute('x', node.style.cssText);
          node.setAttribute('style', `--y: ${originalY}px; --x: ${originalX - shiftMargin}px`);
        }
      }
    }
  } 
  else {
    //shift the xPos of every node by the margin to the right so that furthest left node is 100px from left edge
    shiftMargin = 50;
    for (let values of dataMap.values()) {
      for (let i = 0; i < values.length; ++i) {
        if (isOnTree(values[i])) {
          let node = document.getElementById(values[i].image);
          let originalY = parseAttribute('y', node.style.cssText);
          let originalX = parseAttribute('x', node.style.cssText);
          node.setAttribute('style', `--y: ${originalY}px; --x: ${originalX + shiftMargin}px`);
        }
      }
    }
  }
}

function shiftTree(xBuffer, tree) {
  
  //Get the leftmost XPos on tree
  let xPos;

  //Gets initial val
  xPos = getX(tree[0].image);

  //Gets furthest left xPos Val
  for (let i = 0; i < tree.length; ++i) {
    let checkXPos = getX(tree[i].image);
    if (checkXPos < xPos) {
      xPos = checkXPos;
    }
  }

  let margin = Math.abs(xPos - xBuffer);
  //shift the xPos of every node by the margin
  for (let i = 0; i < tree.length; ++i) {
    let node = document.getElementById(tree[i].image);
    let originalY = parseAttribute('y', node.style.cssText);
    let originalX = parseAttribute('x', node.style.cssText);
    node.setAttribute('style', `--y: ${originalY}px; --x: ${originalX + margin}px`);
  }
}

function getFurthestXOfTree(tree) {
  let xPos = 0;
  for (let i = 0; i < tree.length; ++i) {
    if (isOnTree(tree[i])) {
      let compareX = getX(tree[i].image);
      if (compareX > xPos) {
        xPos = compareX;
      }
    }
  }
  return xPos;
}

function getXBuffer(tree) {

  let previousVal = null;

  //Since this function is being iterated over, the position of the tree in dataMap is important, every tree before it has already been placed
  //This function only needs to get the furthest right xPos of the tree that was placed before it, ignoring all others. This loop checks for that using previousVal
  for (let value of dataMap.values()) {
    if (getKeyofVal(value[0]) == getKeyofVal(tree[0])) {
      if (previousVal != null) {
        return getFurthestXOfTree(previousVal) + 100;
      }
    }
    previousVal = value;
  }
  return 0;
}

/**
 * Adjusts all of the x positioning of nodes in the tree.
 * @param {the tree that's passed in} tree 
 * @param {the root node of the tree} rootNode 
 */
function fixGenerationSpacing(tree, rootNode) {
  
  //let highestGen = getHighestGenInTree(1, tree);
  let highestGen = getLongestGenChain();
  let rootNodeGen = getGeneration(rootNode);

  //BASE CASE: continue calling fixGenSpacing until the highest gen of the tree is reached
  if (rootNodeGen <= highestGen) {
    
    if (hasChildren(rootNode)) {

      //get all the children of the rootNode
      let rootNodeChildren = getChildren(rootNode);
      let spacing = getSpaceBetweenNodes(rootNodeGen + 1);
      
      let newXPositions = new Map();
    
      //iterate through all the children of the root node
      for (let i = 0; i < rootNodeChildren.length; i++) {
        
        //define the current node and its XPos
        let currChild = rootNodeChildren[i];
        let currChildSpouse = getNode(currChild.spouse);
        let currChildXPos = getX(currChild.image);
        
        //need to update the xPos initially to make sure the child nodes are in the right location
        updateXPos(currChild, currChildXPos);

        if (i > 0) {
          //define the previous rootNodeChild and its XPos
          let prevChild = rootNodeChildren[i - 1];
          let prevChildXPos = getX(prevChild.image);
          let updatedXPos;
          
          //update the current node's xPos by the previous child's xPos plus a set amount
          updatedXPos = prevChildXPos + spacing;
          
          let rightmostChild;
          let rightmostChildXPos;
          let childOverlap = false;
          let hiddenChildren = false;
          
          if (hasChildren(prevChild) && ((hasChildren(currChild) || hasChildren(currChildSpouse)))) {
            
            if (hasHiddenChildren(prevChild)) {
              console.log(`Found hidden children: ${prevChild.name}`);
              hiddenChildren = true;
            }
            
            //get the rightmostChild of the prevChild
            rightmostChild = getFarthestDownRightChild(prevChild, rootNodeGen + 1);
            rightmostChildXPos = getX(rightmostChild.image);
            
            childOverlap = true;
          }
          
          let prevChildSpouse;
          let prevChildSpouseXPos;
          
          //if prevChild has a spouse, then update currChild by prevChild spouse's XPos
          if (hasSpouse(prevChild)) {
            
            prevChildSpouse = getNode(prevChild.spouse);
            prevChildSpouseXPos = getX(prevChildSpouse.image); 
    
            updatedXPos = prevChildSpouseXPos + spacing;
            
            if (hasChildren(prevChildSpouse) && (hasChildren(currChild) || hasChildren(currChildSpouse)) && !childOverlap) {
              
              if (hasHiddenChildren(prevChildSpouse)) {
                console.log(`Found hidden children: ${prevChildSpouse.name}`);
                hiddenChildren = true;
              }
              
              //get the rightmostChild of the prevChildSpouse
              rightmostChild = getFarthestDownRightChild(prevChildSpouse, rootNodeGen + 1);
              rightmostChildXPos = getX(rightmostChild.image);

              childOverlap = true;
            }

            if (prevChildSpouseXPos > rightmostChildXPos) {
              rightmostChildXPos = prevChildSpouseXPos + spacing;
            }
          }
          
          if (childOverlap) {

            let leftmostChild;
            let leftmostChildXPos;

            let diff;
            //get the leftmostChild of the currChild
            if (hasChildren(currChildSpouse)) {
              leftmostChild = getFarthestDownLeftChild(currChildSpouse, rootNodeGen + 1);
              leftmostChildXPos = getX(leftmostChild.image);
              let currChildSpouseXPos = getX(currChildSpouse.spouse);
              diff = currChildSpouseXPos - leftmostChildXPos;
            }
            if (hasChildren(currChild)) {
              leftmostChild = getFarthestDownLeftChild(currChild, rootNodeGen + 1);
              leftmostChildXPos = getX(leftmostChild.image);
              diff = currChildXPos - leftmostChildXPos;
            }

            //check to prevent overlap from spouses in higher gens
            if (hasSpouse(rightmostChild) || (hasSpouse(getNode(rightmostChild.mother)) && getGeneration(currChild) >= 3)) {
              rightmostChildXPos += spacing;
            }

            updatedXPos = rightmostChildXPos + diff;
          }
          
          if (hasHiddenChildren(currChild) || hasHiddenChildren(currChildSpouse)) {
            hiddenChildren = true;
          }

          if (hiddenChildren) {
            if (prevChildSpouse != null) {
              updatedXPos = prevChildSpouseXPos + spacing;

              if (currChildXPos - prevChildSpouseXPos != spacing) {
                updateXPos(currChild, prevChildSpouseXPos + spacing);
              }
            } else {
              updatedXPos = prevChildXPos + spacing;

              if (currChildXPos - prevChildXPos != spacing) {
                updateXPos(currChild, prevChildXPos + spacing);
              }
            }
          }
          
          //add updated xPos to newXPositions
          newXPositions.set(currChild, updatedXPos);
          
          //update all node's x positions with their new X positions
          updateXPos(currChild, newXPositions.get(currChild));

          shiftOverlappingNodes(rootNodeChildren, spacing);
          
          //A check needed to prevent overlap of spouses with previously updated nodes
          if (hasSpouse(prevChild)) {
            currChildXPos = getX(currChild.image);
            prevChildSpouseXPos = getX(prevChildSpouse.image);

            if (currChildXPos - prevChildSpouseXPos < spacing) {
              updatedXPos += spacing - (currChildXPos - prevChildSpouseXPos);
              newXPositions.set(currChild, updatedXPos);
              updateXPos(currChild, newXPositions.get(currChild));
            }
          } 
        }

        //RECURSIVE CALLS: for each rootNodeChild, call fixGenSpacing
        if (hasChildren(currChildSpouse)) {
          fixGenerationSpacing(tree, currChildSpouse);
          adjustRootNode(currChildSpouse);
        }
        else {
          fixGenerationSpacing(tree, currChild);
          adjustRootNode(currChild);
        }
      }
    }
  }
}

/**
 * Accounts for any unforseen overlapping nodes 
 * @param {the children of the rootNode} rootNodeChildren 
 * @param {how much space to put between each node} spacing 
 */
function shiftOverlappingNodes(rootNodeChildren, spacing) {

  //Loop through all of the rootNodeChildren
  for (let i = 1; i < rootNodeChildren.length; i++) {
    
    let currMother = getMotherNode(rootNodeChildren[i]);
    let currChildren;
      
    //get children of the current Mother or its spouse
    if (hasChildren(currMother)) {
      currChildren = getChildren(currMother);
    }
    
    if (currChildren != null && !hasHiddenChildren(currMother)) {
      //loop through all of the nodes previous to the currMother
      for (let j = i - 1; j >= 0; j--) {

        let prevMother = getMotherNode(rootNodeChildren[j]);
        let prevChildren;

        //get children of the previous Mother or its spouse
        if (hasChildren(prevMother)) {
          prevChildren = getChildren(prevMother);
        }

        //if the previous node has children
        if (prevChildren != null && !hasHiddenChildren(prevMother)) {
          
          //get the leftmost child of the current node and rightmost child of the previous node
          let rightmostChild = getFarthestDownRightChild(getMotherNode(prevMother), getGeneration(prevMother) + 1);
          let rightmostChildXPos = getX(rightmostChild.image);

          let leftmostChild = getFarthestDownLeftChild(getMotherNode(currMother), getGeneration(currMother) + 1);
          let leftmostChildXPos = getX(leftmostChild.image);

          if ((leftmostChildXPos - rightmostChildXPos < spacing) && (getGeneration(leftmostChild) == getGeneration(rightmostChild))) {
            let currChildXPos = getX(getMotherNode(currMother).image);
            let diff = currChildXPos - leftmostChildXPos;
            
            //check to prevent overlap from spouses in higher gens
            if (hasSpouse(rightmostChild) || (hasSpouse(getNode(rightmostChild.mother)) && getGeneration(currMother) >= 3)) {
              rightmostChildXPos += spacing;
            }

            let updatedXPos = rightmostChildXPos + spacing + diff;
            updateXPos(currMother, updatedXPos);

            if (hasSpouse(currMother)) {
              if (currMother != rootNodeChildren[i] && getX(getNode(currMother.spouse).image) != getX(currMother.image) - 100) {
                setX(getNode(currMother.spouse), getX(currMother.image) - 100);
              }
            }
          }
        }
      }
    }
  }
}

function getSpaceBetweenNodes(gen) {
  let spacing = 120;
  
  if (gen == 2) {
    return spacing;
  }
  else {
    spacing = 70;
  }
  return spacing;
}

/**
 * Updates the X position of a node, its spouse, and its children by a specified amount
 * @param {the current node that's passed in} node 
 * @param {the xPos to update the node with} newXPos 
 */
function updateXPos(node, newXPos) {
  //updates xPos of the node
  if (!isHidden(node)) {setX(node, newXPos);}
  let nodeChildren;
  let hasDescendants = false;
  
  //if node has spouse
  if (node.spouse != null) {
    let nodeSpouse = getNode(node.spouse);

    if (!isHidden(nodeSpouse)) {
      newXPos = newXPos + 100;
      setX(nodeSpouse, newXPos);
    }
    
    //if node's spouse has children
    if (hasChildren(nodeSpouse) && !hasHiddenChildren(nodeSpouse)) {
      nodeChildren = getChildren(nodeSpouse);
      shiftChildrenX(nodeSpouse, nodeChildren);
      hasDescendants = true;
    }
  }
  //if node has children
  if (hasChildren(node) && !hasHiddenChildren(node)) {
    nodeChildren = getChildren(node);
    shiftChildrenX(node, nodeChildren);
    hasDescendants = true;
  }

  if (hasDescendants) {
    for (let i = 0; i < nodeChildren.length; i++) {
      updateXPos(nodeChildren[i], getX(nodeChildren[i].image));
    }
  }
}

function shiftChildrenX(nodeMother, nodeChildren) {
  
  //get the XPos of the mother node
  let motherXPos = getX(nodeMother.image);
  
  //set spacing between children (can change later)
  let spacing = 70;

  //define the factor to shift all the child nodes by so they are centered under the mother
  let shiftFactor = spacing * ((nodeChildren.length - 1) / 2);

  let newXPositions = new Map();
  for (let childId = 0; childId < nodeChildren.length; childId++) {
    let currChild = nodeChildren[childId];
    
    //set the childXPos as a factor of spacing
    let newChildXPos = motherXPos + spacing * childId - shiftFactor;

    //store the newXPositions in a map
    newXPositions.set(currChild, newChildXPos);

    //set the newXPositions shifted over by the shiftFactor
    setX(currChild, newXPositions.get(currChild));
  }
}

/** 
 * Finds the x positions of the leftmost and rightmost child 
 * of the root node and sets the x position of the rootnode
 * and root spouse at the central position of those two nodes.
**/
function adjustRootNode(rootNode) {

  //In case this tree has no children yet is still root node ie just a spouse tree (2 nodes)
  if (!hasChildren(rootNode) || hasHiddenChildren(rootNode)) {
    return;
  }
  
  //define the leftmost and rightmost children of the rootNode
  let leftmostChild = getLeftmostChild(rootNode);
  let rightmostChild = getRightmostChild(rootNode);
  let leftChildX = getX(leftmostChild.image);
  let rightChildX = getX(rightmostChild.image);
  let originalXPos = getX(rootNode.image);
  
  //Will place root node in the middle of the rightMost and leftMost children
  let newXPos = (leftChildX + rightChildX) / 2;

  if (newXPos != originalXPos) {
    //set the newXPos for rootNode and its spouse
    setX(rootNode, newXPos);
    
    let rootNodeSpouse = getNode(rootNode.spouse);
    if (rootNodeSpouse != null) {
      let spouseMother = getNode(rootNodeSpouse.mother); 
      if (spouseMother != null) {
        setX(rootNodeSpouse, newXPos - 100);
      } 
      else {
        setX(rootNodeSpouse, newXPos + 100);
      }
    }
  }
}

function setX(node, newXPos) {
  let nodeElement = document.getElementById(node.image);
  let originalY = parseAttribute('y', nodeElement.style.cssText);
  nodeElement.setAttribute('style', `--y: ${originalY}px; --x: ${newXPos}px`);
}

/**
 * Sets the initial xPos of a node in createDataPoints
 * @param {the node that's passed in} node 
 * @param {the generation of that node } gen 
 * @returns the initial xPos of that node
 */
function setInitialX(currGen, placeInGen) {
  let xPos = (chartWidth / (getNumInGeneration(currGen) + 1)) * placeInGen;
  return xPos;
}


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



//All helper functions to access data, etc.



function hasSpouse(node) {
  if (node == null) {return false}
  
  if (node.spouse != null) {
    return true;
  } else {
    return false;
  }
}

/**
 * Checks through all the trees and the nodeBox
 * @param {*node.image of the node we are looking for} nodeId 
 * @returns node with the matching nodeId
 */
function getNode(nodeId) {
  if (nodeId == null) {
    return null;
  }
  
  //checks trees for node
  for (let value of dataMap.values()) {
    for (let i = 0; i < value.length; ++i) {
      if (value[i].image == nodeId) {
        return value[i];
      }
    }
  }
  //checks nodeBox for node
  for (let i = 0; i < nodeBoxData.length; i++) {
    if (nodeBoxData[i].image == nodeId) {
      return nodeBoxData[i];
    }
  }
}

function getTree(node) {
  for (let value of dataMap.values()) {
    for (let i = 0; i < value.length; ++i) {
      if (value[i] == node) {
        return value;
      }
    }
  }
}

function getX(nodeId) {
  if (nodeId != null) {
    let thisNode = document.getElementById(nodeId);
    let nodeXPos = parseAttribute('x', thisNode.style.cssText);
    return nodeXPos;
  }
}

function getY(nodeId) {
  if (nodeId != null) {
    let thisNode = document.getElementById(nodeId);
    let nodeXPos = parseAttribute('y', thisNode.style.cssText);
    return nodeXPos;
  }
}

function setY(generation, genCount) {
  return (chartWidth + 250) - (chartWidth / genCount + 1) * generation;
}

function getLongestGenChain() {
  let genCount = 0;
  for (let value of dataMap.values()) {
    for (let i = 0; i < value.length; ++i) {
      let tmp = getGenerationCount(value[i], 1);
      if (tmp > genCount) {
        genCount = tmp;
      }
    }
  }
  return genCount;
}

function getDataIndex(id) {
  for (let value of dataMap.values()) {
    for (let i = 0; i < value.length; ++i) {
      if (id == value[i].image) {
        return i;
      }
    }
  }
  return null;
}

function removeNodeFromTree(node) {
  for (let value of dataMap.values()) {
    for (let i = 0; i < value.length; ++i) {
      if (node.image == value[i].image) {
        value.splice(i, 1);
      }
    }
  }
}

function deleteNode(id) {

  let node = getNode(id)

  let execute = confirm("This person will be permanently deleted, are you sure you want to proceed?")

  if (!execute) {
    return;
  }

  let deleted = false;
  for (let value of dataMap.values()) {
    for (let i = 0; i < value.length; ++i) {
      //Deletes any instances of node
      if (value[i].image == id) {
        value.splice(i,1)
        i--;
        deleted = true;
        continue
      }
      //If any node has it as spouse, set to null
      if (value[i].spouse == id) {
        value[i].spouse = null;
      }
      //if any node has it as mother, set to null
      if (value[i].mother == id) {
        value[i].mother = null;
      }

      //if the value ends up having no relationships because of deletion, put in node container
      if (!hasRelationship(value[i])) {
        addToNodeContainer(value[i].image)
        document.getElementById(`${value[i].image}`).remove();
        //removeNodeFromTree(value[i])
        value.splice(i,1);
        i--;
        continue
      }

      if (value[i].mother == null) {
        //FIXME: getnode spouse is returning undefined
        if ((value[i].spouse != null && getNode(value[i].spouse).mother == null) || value[i].spouse == null) {
          let children = getChildren(node);
          if (children == null) {continue}
          for (let j = 0; j < children.length; ++j) {
            if (hasChildren(children[j])) {
              let descendants = getDescendants(children[j], [])
              descendants.push(children[j])
              dataMap.set(children[j].image, descendants);
            }
          }

          dataMap.delete(node.image)
        }
      }
    }
  }

  document.getElementById(`${id}`).remove();

  if (deleted) {
    closeMenu();
    momArray = makeMomArray();
    createChart();
  }
}

function getNodeBoxDataIndex(id) {
  for (let i = 0; i < nodeBoxData.length; ++i) {
    if (id == nodeBoxData[i].image) {
      return i;
    }
  }
  return null;
}

function getMomArrayIndex(array, id) {
  for (let i = 0; i < array.length; ++i) {
    if (array[i].data.image == id) {
      return i;
    }
  }
}

function isOnTree(node) {
  let thisNode = document.getElementById(node.image);

  if (thisNode == null) {
    return false;
  }
  else {
    return true;
  }
}

function getHypotenuse(datapoint1, datapoint2, left1, left2) {
  triSide = datapoint1 - datapoint2;
  tmpSpacing = left1 - left2;
  hypotenuse = Math.sqrt((triSide * triSide) + (tmpSpacing * tmpSpacing));
  return hypotenuse;
}

function getAngle(opposite, hypotenuse) {
  let sine = Math.asin(opposite / hypotenuse);
  //Convert from radians to degrees
  sine = sine * (180 / Math.PI);

  return sine;
}

function parseAttribute(lookFor, attribute) {
  let numString = '';
  if (lookFor == 'y') {
    for (let i = 0; i < attribute.length; ++i) {
      if (attribute[i] == 'y') {
        let j = i + 2 //skips colon and white space
        while (attribute[j] != 'p') {
          numString += attribute[j];
          j++;
        }
        break;
      }
    }
  }

  if (lookFor == 'x') {
    for (let i = 0; i < attribute.length; ++i) {
      if (attribute[i] == 'x' && attribute[i - 1] != 'p') {
        let j = i + 2; //skips colon and white space
        while (attribute[j] != 'p') {
          numString += attribute[j];
          j++;
        }
      }
    }
  }
  return parseInt(numString);
}

function hasRelationship(node) {
  if (node.spouse != null || node.mother != null) {
    return true;
  }
  else if (hasChildren(node)) {
    return true;
  }
  return false
}

//Added these two functions to check for hidden nodes
function hasHiddenChildren(node) {
  if (node == null || !hasChildren(node)) {return false;}
  let nodeChildren = getChildren(node);
  let testChild = nodeChildren[0];
  let testChildElement = document.getElementById(`${testChild.image}`);
  
  if (testChildElement.style.visibility == "hidden") {
    return true;
  } else {
    return false;
  }
}

function isHidden(node) {
  let nodeElement = document.getElementById(`${node.image}`);

  if (nodeElement.style.visibility == "hidden") {
    return true;
  } else {
    return false;
  }
}

function getGenerationCount(node, count) {

  if (node?.mother == null) {
    if (node?.spouse != null) {
      let spouse = getNode(node.spouse);
      if (spouse.mother != null) {
        let mother = getNode(spouse.mother);
        return count += getGenerationCount(mother, count);
      }
      else {
        return count;
      }
    }
    else {
      return count;
    }
  }

  let motherNode = getNode(node.mother);

  if (node.mother != null) {
    return count += getGenerationCount(motherNode, count);
  }
}

function getGeneration(node) {
  let count = 1;

  count = getGenerationCount(node, count);

  return count;
}

function getHighestGenInTree(gen, tree) {
  let nodesInGen = getNodesInGeneration(gen);
  let nodesInTree = [];

  for (let i = 0; i < nodesInGen.length; i++) {
    if (tree.includes(nodesInGen[i])) {
      nodesInTree.push(nodesInGen[i]);
    }
  }
  if (nodesInTree.length > 0) {
    return getHighestGenInTree(gen + 1, tree);
  }
  return gen - 1;
}

function getNumInGeneration(generation) {
  let numInGen = 0;
  for (let value of dataMap.values()) {
    for (let i = 0; i < value.length; ++i) {
      if (getGeneration(value[i]) == generation) {
        numInGen++;
      }
    }
  }
  return numInGen;
}

function getNodesInGeneration(generation) {
  let nodeGeneration = [];
  for (let value of dataMap.values()) {
    for (let i = 0; i < value.length; ++i) {
      if (getGeneration(value[i]) == generation) {
        nodeGeneration.push(value[i]);
      }
    }
  }
  return nodeGeneration;
}

function getChildren(motherNode) {

  if (motherNode == null) {
    console.log("Node " + motherNode.image + " does not exist")
    return null
  }

  if (hasChildren(motherNode)) {
    for (let i = 0; i < momArray.length; ++i) {
      if (motherNode.image == momArray[i].data.image) {
        return momArray[i].children;
      }
    }
  }
  return [];
}

function hasChildren(node) {
  if (node == null) {
    return false;
  }

  for (let i = 0; i < momArray.length; ++i) {
    if (momArray[i].data.image == node.image) {
      return true;
    }
  }
  return false;
}

function getRootNode(node) {
  //check if node is the root node
  if (node.mother == null && getNode(node.spouse)?.mother == null) {
    if (!hasChildren(node) && node.spouse != null && hasChildren(getNode(node.spouse))) {
      return getNode(node.spouse);
    }
    else {
      return node;
    }
  }
  //if node is not the root node, then recursively check
  else {
    if (node.mother != null) {
      return getRootNode(getNode(node.mother));
    }
    if (node.spouse != null) {
      if (getNode(node.spouse).mother != null) {
        return getRootNode(getNode(getNode(node.spouse).mother));
      }
    }
  }
}

function getMotherNode(node) {
  if (hasSpouse(node)) {
    let spouse = getNode(node.spouse);
    if (hasChildren(spouse)) {
      return spouse;
    }
  }
  return node;
}

function getLeftmostChild(momNode) {
  let childElementXPos;
  let leftmostChild;

  for (let i = 0; i < momArray.length; ++i) {

    if (momArray[i].data.image == momNode.image) {

      //Initial comparing value
      let tmpChild = document.getElementById(`${momArray[i].children[0].image}`);
      childElementXPos = parseAttribute('x', tmpChild.style.cssText)
      leftmostChild = tmpChild.id

      for (let j = 0; j < momArray[i].children.length; ++j) {
        let child = document.getElementById(`${momArray[i].children[j].image}`);

        let childXPos = parseAttribute('x', child.style.cssText);

        if (childXPos < childElementXPos) {
          childElementXPos = childXPos;
          leftmostChild = child.id
        }
      }
      break;
    }
  }
  return getNode(parseInt(leftmostChild));
}

function getFarthestDownLeftChild(momNode, gen) {
  let leftmostNode = getLeftmostChild(momNode);
  let currGen = getGeneration(leftmostNode);
  if (hasChildren(leftmostNode) && currGen <= gen) {
    return getFarthestDownLeftChild(leftmostNode);
  }
  return leftmostNode;
}

function getFarthestDownRightChild(momNode, gen) {
  let rightmostNode = getRightmostChild(momNode);
  let currGen = getGeneration(rightmostNode);
  if (hasChildren(rightmostNode) && currGen <= gen) {
    return getFarthestDownRightChild(rightmostNode);
  }
  
  if (hasSpouse(rightmostNode)) {
    return getNode(rightmostNode.spouse);
  } else {
    return rightmostNode;
  }
}

function getRightmostChild(momNode) {
  let childElementXPos;
  let rightmostChild;

  for (let i = 0; i < momArray.length; ++i) {
    if (momArray[i].data.image == momNode.image) {

      //Initial comparing value
      let tmpChild = document.getElementById(`${momArray[i].children[0].image}`);
      childElementXPos = parseAttribute('x', tmpChild.style.cssText)
      rightmostChild = tmpChild.id

      for (let j = 0; j < momArray[i].children.length; ++j) {
        let child = document.getElementById(`${momArray[i].children[j].image}`);

        let childXPos = parseAttribute('x', child.style.cssText);

        if (childXPos > childElementXPos) {
          childElementXPos = childXPos;
          rightmostChild = child.id;
        }
      }
      break;
    }
  }
  return getNode(parseInt(rightmostChild));
}

function inNodeBox(node) {
  if (getNodeBoxDataIndex(node.image) != null) {
    return true;
  } else {
    return false;
  }
}

function getTreeLine(node, tree) {

  //If node is Mother gets children
  let children = getChildren(node);

  tree.push(node)
  if (node.spouse != null) {
    tree.push(getNode(node.spouse))
  }

  //If node is Father gets children of wife if their is any
  if (children.length == 0) {
    if (node.spouse != null) {
      children = getChildren(getNode(node.spouse));
    }
  }

  //Base Case
  if (children.length == 0) {
    return tree;
  }
  else {
    for (let i = 0; i < children.length; ++i) {
      tree.push(children[i]);
    }
  }

  for (let i = 0; i < children.length; ++i) {
    tree.push(children[i]);
    if (children[i].spouse != null) {
      tree.push(getNode(children[i].spouse));
    }

    if (hasChildren(children[i]) || (children[i].spouse != null && hasChildren(getNode(children[i].spouse)))) {
      getTreeLine(children[i], tree)
    }
  }

  //To remove duplicates
  tree = new Set(tree);
  tree = Array.from(tree);

  return tree;
}

//In case root nodes aren't the mother, addRelationship functions may cause this when both nodes are in nodeBox
//Checks if root node or spouse has children, if yes, makes that node the rootNode, else, it doesn't matter who root node is
function checkRootNode() {
  for (let key of dataMap.keys()) {
    let tmpNode = getNode(key);
    let tmpSpouse = getNode(tmpNode.spouse)
    //If has children do nothing
    if (hasChildren(tmpNode)) {
      continue;
    }
    if (tmpSpouse != null && hasChildren(tmpSpouse)) {
      let tmpTree = dataMap.get(key);
      dataMap.set(tmpSpouse.image, tmpTree)
      dataMap.delete(key);
    }
  }
}

//If confirmBox menu is exited without changing relationship, confirmBox is cleared, this is to make sure that no node is lost
function returnConfirmBoxNodes(id1, id2) {
  let node1 = getNode(id1);
  let node2 = getNode(id2);

  if (!hasRelationship(node1) && node1 != null) {
    addToNodeContainer(id1);
  }
  if (!hasRelationship(node2) && node2 != null) {
    addToNodeContainer(id2);
  }
}

//FOR PRESENTATION
function startEmpty() {

  //for (let value of dataMap.values()) {
  //  removeTreeFromChart(value)
  //}

  for (let value of dataMap.values()) {
    while (value.length != 0) {
      value[0].mother = null;
      value[0].spouse = null;
      addToNodeContainer(value[0].image);
      value.splice(0, 1);
    }
  }

  dataMap.clear();

  momArray = [];
  
  createChart();
}

function getDescendants(node, children) {

  //Adds Spouse of Node
  if (node.spouse != null) {
    let inTree = false;
    //Checks if already in tree to avoid duplicates
    for (let i = 0; i < children.length; ++i) {
      if (children[i].image == node.spouse) {
        inTree = true;
      }
    }
    if (!inTree) {
      children.push(getNode(node.spouse))
    }
  }

  //Base Case
  if (!hasChildren(node)) {
    return children;
  }

  let nodeChildren = getChildren(node);



  //The recursive call, either calls this function on node's children or spouses children
  for (let i = 0; i < nodeChildren.length; ++i) {
    let spouse = getNode(nodeChildren[i].spouse);
    children.push(nodeChildren[i])

    if (spouse != null) {
      children.push(spouse);
    }

    if (hasChildren(nodeChildren[i])) {
      getDescendants(nodeChildren[i], children);
    }

    if (spouse != null && hasChildren(spouse)) {
      getDescendants(spouse, children);
    }
  }
  return children;
}

//You only want to go up by the node's mother, do not access spouse mother

function getHiddenFamily(id) {

  let node = getNode(id);

  if (node.mother == null) {
    alert("Does not have hidden family.");
    return;
  }

  //This will get the root node of that family tree
  let newActiveRoot = getSpecificFamilyRoot(node);

  let hiddenFamily = getDescendants(newActiveRoot, []);
  //Adds root to hiddenFamily array
  hiddenFamily.push(newActiveRoot);


  //Gets the oldKey
  let oldActiveRoot = getNode(getKeyofVal(getNode(id)))

  //Creates new dataMap entry with the new activeRoot as key
  dataMap.set(newActiveRoot.image, dataMap.get(oldActiveRoot.image));
  
  //Deletes old map with oldActiveRoot
  dataMap.delete(oldActiveRoot.image);

  createChart();
}

function getSpecificFamilyRoot(node) {
  if (node.mother == null) {
    return node;
  }
  else {
    let mother = getNode(node.mother);
    return getSpecificFamilyRoot(mother);
  }
}

//Front End Functions
function zoomIn() {
  let treeChart = document.getElementById("treeChart");
  let currZoom = treeChart.style.zoom;
  currZoom = parseFloat(currZoom);

  if (currZoom == 1.4) {
    treeChart.style.zoom = 1.4;
    return
  }

  let newZoom = currZoom + .1;
  treeChart.style.zoom = `${newZoom}`;
}

function zoomOut() {
  let treeChart = document.getElementById("treeChart");
  let currZoom = treeChart.style.zoom;
  currZoom = parseFloat(currZoom);

  if (currZoom == .7) {
    treeChart.style.zoom = .7;
    return
  }

  let newZoom = currZoom - .1;

  treeChart.style.zoom = `${newZoom}`;
}

function resetZoom() {
  let treeChart = document.getElementById("treeChart");
  treeChart.style.zoom = 1;
}

function hideTree(id) {

  let node = getNode(id);

  let descendants = getDescendants(node, []);

  //Hides Descendants Nodes
  for (let i = 0; i < descendants.length; ++i) {
    if (descendants[i].image == node.spouse) {continue;} 
    let el = document.getElementById(`${descendants[i].image}`);
    el.style.visibility = "hidden";
    if (hasChildren(descendants[i])) {
      changeButton(descendants[i].image, "hide");
    }
  }

  //CreatLine functions creates lines that connect to only visible nodes
  //shiftChart(getTree(node));
  fixGenerationSpacing(getTree(node), getRootNode(node));
  adjustRootNode(getNode(getKeyofVal(node)));
  createLines();
}

function showTree(id) {
  let node = getNode(id);
  let descendants = getDescendants(node, []);

  //Reveals Descendant Nodes
  for (let i = 0; i < descendants.length; ++i) {
    if (descendants[i].image == node.spouse) {continue;}
    let el = document.getElementById(`${descendants[i].image}`);
    el.style.visibility = "visible";
    if (hasChildren(descendants[i])) {
      changeButton(descendants[i].image, "show");
    }
  }

  //CreatLine functions creates lines that connect to only visible nodes
  //shiftChart(getTree(node));
  fixGenerationSpacing(getTree(node), getRootNode(node));
  adjustRootNode(getNode(getKeyofVal(node)));
  createLines();
}

function tutorial() {

  let pageContainer = document.getElementById("page-container");

  for (let i = 0; i < pageContainer.children.length; ++i) {
    let id = pageContainer.children[i].getAttribute("id")
    if (id != "navButton") {
      document.getElementById(`${id}`).style.filter = "blur(2px)"
    }
  }
 
  //$("#page-container").css("filter", "blur(2px)");
  $("#header").css("filter", "blur(2px)");
  $("#footer").css("filter", "blur(2px)");



  $("#tutorial").html(
    `<div class="tutorial-box">
      <div><button class="x-button" style="margin-right: 10px;" onclick="closeTutorial()"><strong>X</strong></button></div>
      <div style="margin: 10px; font-family: Arial;">
        <p>Photo Family Tree is an interactive new experience for creating and making adjustments to a family tree.
        In this tree you can change relationships and make new ones with the click of a button! To try this new experience, we are using one of the United State's most prominant families, 
        the <a href="https://www.jfklibrary.org/learn/about-jfk/the-kennedy-family" target="_blank">Kennedy's</a>.
        Eventually, with your permission, we would like to have you be able to automatically create your own family tree using your own family photos!</p>

        <p>Just to explain how this software is used here are a few guidelines:</p>

        <ul>
        <li><p><strong>Lines:</strong> A <strong>black</strong> line represents a parent-child relationship while a <strong style="color: blue">blue</strong> line represents a spouse relationship.</p></li>
          <li><p>To <strong>remove a relationship</strong> you can just click on a line and choose "Remove Relationship" on the menu that opens.</p></li>
          <li><p>To <strong>add a relationship</strong> you can click on two photos and add whichever relationship you would like.</p></li>
          <li><p>To <strong>edit info</strong> about a person just click on one person and choose "Edit Info"</p></li>
          <li><p>People that have no relationships are placed at the bottom of the page. Click the person icon to view them</p></li>
          <li><p>Sometimes people have families that are not shown on the tree, this is to make sure that the tree is presented nicely. These nodes have a <strong style="color: #97694F">tan</strong> border around them.
          If a person on the tree has a family that is not shown, simply click on that person and press the "Show Hidden Family" button, that will make their respective family tree appear.</p></li>
          
        </ul>

        <p><strong>Note:</strong> Our spacing algorithm works great in normal circumstances! However, there are a few complicated relationships where the spacing will start
        to behave strangely. If this happens, just reload the page to start over again. Please be patient as we try to correct these mistakes and make it easier for you to use!</p>
      </div>
    </div>`
  )
}

function closeTutorial() {
  $("#tutorial").html('')

  let pageContainer = document.getElementById("page-container");

  for (let i = 0; i < pageContainer.children.length; ++i) {
    if (pageContainer.children[i].id != "navButton") {
      let id = pageContainer.children[i].getAttribute("id")
      document.getElementById(`${id}`).style.filter = "blur(0px)"
    }
  }

  //$("#page-container").css("filter", "blur(0px)");
  $("#header").css("filter", "blur(0px)");
  $("#footer").css("filter", "blur(0px)");
}

function isDescendant(node, ancestor) {

  let descendants = getDescendants(ancestor, []);

  for (let i = 0; i < descendants.length; ++i) {
    if (descendants[i].image == node.image) {
      return true;
    }
  }

  return false;
}

function getKeyofVal(node) {

  let focusNodeKey = null

  dataMap.forEach((value, key) => {
    for (let i = 0; i < value.length; ++i) {
      if (value[i].image == node.image) {
        focusNodeKey = key;
      }
    }
  })

  if (focusNodeKey != null) {
    return focusNodeKey;
  }

  alert("No key found");
  return null
}

function hasHiddenFamily(node) {
  if (node.mother == null) {
    return false;
  }
  else if (node.mother != null && document.getElementById(`${node.mother}`) == null) {
    return true;
  }
  else {
    return false;
  }
}

function openNavBottom() {
  document.getElementById("myBottomnav").style.width = "100%";
  document.getElementById("myBottomnav").style.height = "auto";
}

/* Set the width of the bottom navigation to 0 and the bottom margin of the page content to 0 */
function closeNavBottom() {
  document.getElementById("myBottomnav").style.width = "0";
  document.getElementById("myBottomnav").style.height = "0";
}
